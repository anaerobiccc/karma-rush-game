<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Karma Rush: Reddit Multiverse - Professional Edition</title>
    
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#FF4500">
    
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <!-- Professional Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Space+Grotesk:wght@300;400;700&display=swap" rel="stylesheet">
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
        }
        
        body {
            overflow: hidden;
            font-family: 'Space Grotesk', -apple-system, BlinkMacSystemFont, sans-serif;
            background: #000;
            position: fixed;
            width: 100vw;
            height: 100vh;
        }
        
        #gameCanvas {
            width: 100%;
            height: 100%;
            display: block;
            position: absolute;
            top: 0;
            left: 0;
        }
        
        /* PROFESSIONAL LOADING SCREEN */
        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: radial-gradient(circle at center, #1a1a2e, #0a0a0f);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            transition: opacity 1s ease;
        }
        
        .loading-screen.hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        .loading-spinner {
            width: 80px;
            height: 80px;
            border: 4px solid rgba(255, 69, 0, 0.2);
            border-top: 4px solid #FF4500;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .loading-text {
            font-family: 'Orbitron', monospace;
            font-size: 18px;
            color: #FF4500;
            letter-spacing: 2px;
            animation: pulse 1.5s ease infinite;
        }
        
        /* PROFESSIONAL START SCREEN */
        .start-screen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, #0f0f1e 0%, #1a1a2e 50%, #16213e 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            transition: all 0.8s cubic-bezier(0.4, 0, 0.2, 1);
            overflow: hidden;
        }
        
        .start-screen::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(255,69,0,0.1) 0%, transparent 70%);
            animation: rotate 20s linear infinite;
        }
        
        @keyframes rotate {
            to { transform: rotate(360deg); }
        }
        
        .start-screen.hidden {
            opacity: 0;
            transform: scale(1.1);
            pointer-events: none;
        }
        
        .game-logo-container {
            position: relative;
            margin-bottom: 30px;
            animation: float 3s ease-in-out infinite;
        }
        
        @keyframes float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }
        
        .game-logo {
            width: 140px;
            height: 140px;
            background: linear-gradient(135deg, #FF4500, #FF6B35);
            border-radius: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 70px;
            box-shadow: 
                0 20px 40px rgba(255, 69, 0, 0.3),
                inset 0 2px 10px rgba(255, 255, 255, 0.2);
            position: relative;
            overflow: hidden;
        }
        
        .game-logo::after {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg, transparent, rgba(255,255,255,0.3), transparent);
            transform: rotate(45deg);
            animation: shine 3s ease infinite;
        }
        
        @keyframes shine {
            0% { transform: translateX(-100%) translateY(-100%) rotate(45deg); }
            100% { transform: translateX(100%) translateY(100%) rotate(45deg); }
        }
        
        .game-title {
            font-family: 'Orbitron', monospace;
            font-size: 48px;
            font-weight: 900;
            color: white;
            text-shadow: 
                0 0 20px rgba(255, 69, 0, 0.5),
                0 4px 8px rgba(0,0,0,0.5);
            margin-bottom: 10px;
            letter-spacing: 3px;
            position: relative;
            z-index: 1;
        }
        
        .game-subtitle {
            font-size: 16px;
            color: rgba(255,255,255,0.7);
            margin-bottom: 40px;
            letter-spacing: 1px;
            position: relative;
            z-index: 1;
        }
        
        .menu-buttons {
            display: flex;
            flex-direction: column;
            gap: 15px;
            position: relative;
            z-index: 1;
        }
        
        .menu-button {
            padding: 18px 60px;
            font-family: 'Orbitron', monospace;
            font-size: 18px;
            font-weight: 700;
            color: white;
            background: linear-gradient(135deg, #FF4500, #FF6B35);
            border: none;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 
                0 10px 25px rgba(255, 69, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            text-transform: uppercase;
            letter-spacing: 2px;
            position: relative;
            overflow: hidden;
        }
        
        .menu-button::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }
        
        .menu-button:hover::before {
            width: 300px;
            height: 300px;
        }
        
        .menu-button:hover {
            transform: translateY(-2px);
            box-shadow: 
                0 15px 35px rgba(255, 69, 0, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.3);
        }
        
        .menu-button:active {
            transform: translateY(0);
        }
        
        .menu-button.secondary {
            background: linear-gradient(135deg, #667eea, #764ba2);
            box-shadow: 
                0 10px 25px rgba(102, 126, 234, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
        }
        
        /* PROFESSIONAL HUD */
        .game-hud {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 100;
        }
        
        /* TOP BAR */
        .top-bar {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 60px;
            background: linear-gradient(180deg, rgba(0,0,0,0.8) 0%, transparent 100%);
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 20px;
        }
        
        /* SCORE DISPLAY */
        .score-container {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .karma-score {
            font-family: 'Orbitron', monospace;
            font-size: 32px;
            font-weight: 900;
            background: linear-gradient(135deg, #FFD700, #FF4500);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 2px 10px rgba(255, 69, 0, 0.3);
            line-height: 1;
        }
        
        .karma-label {
            font-size: 10px;
            color: rgba(255, 255, 255, 0.6);
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-top: 2px;
        }
        
        /* COMBO METER */
        .combo-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .combo-bar {
            width: 100px;
            height: 8px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            overflow: hidden;
            position: relative;
        }
        
        .combo-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #FF4500, #FFD700);
            transition: width 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 0 10px currentColor;
        }
        
        .combo-text {
            font-family: 'Orbitron', monospace;
            font-size: 14px;
            color: #FFD700;
            font-weight: 700;
            min-width: 50px;
        }
        
        /* DIMENSION INDICATOR */
        .dimension-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            pointer-events: auto;
        }
        
        .dimension-icon {
            width: 30px;
            height: 30px;
            background: linear-gradient(135deg, #FF4500, #FF6B35);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            box-shadow: 0 4px 10px rgba(255, 69, 0, 0.3);
        }
        
        .dimension-name {
            font-family: 'Orbitron', monospace;
            font-size: 14px;
            color: white;
            font-weight: 700;
            text-shadow: 0 2px 5px rgba(0, 0, 0, 0.5);
        }
        
        /* ACHIEVEMENT POPUP */
        .achievement-popup {
            position: absolute;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.95), rgba(255, 140, 0, 0.95));
            padding: 15px 30px;
            border-radius: 50px;
            color: white;
            font-family: 'Orbitron', monospace;
            font-weight: 700;
            font-size: 16px;
            box-shadow: 
                0 10px 30px rgba(0,0,0,0.3),
                inset 0 1px 0 rgba(255,255,255,0.3);
            display: none;
            animation: achievementSlide 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }
        
        .achievement-popup.show {
            display: block;
        }
        
        @keyframes achievementSlide {
            from {
                transform: translateX(-50%) translateY(-100px);
                opacity: 0;
            }
            to {
                transform: translateX(-50%) translateY(0);
                opacity: 1;
            }
        }
        
        /* MOBILE CONTROLS */
        .game-controls {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 30px;
            pointer-events: auto;
            z-index: 101;
        }
        
        .control-button {
            width: 70px;
            height: 70px;
            background: linear-gradient(135deg, rgba(255, 69, 0, 0.2), rgba(255, 69, 0, 0.4));
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 69, 0, 0.6);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 28px;
            color: white;
            box-shadow: 
                0 10px 25px rgba(255, 69, 0, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            transition: all 0.2s;
            cursor: pointer;
        }
        
        .control-button:active {
            transform: scale(0.9);
            background: linear-gradient(135deg, rgba(255, 69, 0, 0.4), rgba(255, 69, 0, 0.6));
        }
        
        /* STATS PANEL */
        .stats-panel {
            position: fixed;
            bottom: 120px;
            left: 20px;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.8), rgba(0, 0, 0, 0.6));
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 69, 0, 0.3);
            border-radius: 15px;
            padding: 15px;
            min-width: 150px;
            display: none;
        }
        
        .stats-panel.show {
            display: block;
            animation: slideIn 0.3s ease;
        }
        
        @keyframes slideIn {
            from {
                transform: translateX(-100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        
        .stat-item {
            display: flex;
            justify-content: space-between;
            color: white;
            font-size: 12px;
            margin: 8px 0;
        }
        
        .stat-label {
            color: rgba(255, 255, 255, 0.6);
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .stat-value {
            font-family: 'Orbitron', monospace;
            color: #FFD700;
            font-weight: 700;
        }
        
        /* PAUSE MENU */
        .pause-menu {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(10px);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 500;
        }
        
        .pause-menu.show {
            display: flex;
        }
        
        .pause-title {
            font-family: 'Orbitron', monospace;
            font-size: 36px;
            color: white;
            margin-bottom: 30px;
            text-shadow: 0 4px 10px rgba(0, 0, 0, 0.5);
        }
        
        /* NOTIFICATION */
        .game-notification {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: 'Orbitron', monospace;
            font-size: 28px;
            font-weight: 900;
            color: #FFD700;
            text-shadow: 
                0 0 20px rgba(255, 215, 0, 0.8),
                0 4px 10px rgba(0,0,0,0.5);
            animation: notificationPop 1s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            pointer-events: none;
            z-index: 200;
        }
        
        @keyframes notificationPop {
            0% {
                transform: translate(-50%, -50%) scale(0) rotate(-180deg);
                opacity: 0;
            }
            50% {
                transform: translate(-50%, -50%) scale(1.2) rotate(10deg);
                opacity: 1;
            }
            100% {
                transform: translate(-50%, -50%) scale(1) translateY(-50px) rotate(0deg);
                opacity: 0;
            }
        }
        
        /* SETTINGS BUTTON */
        .settings-button {
            position: fixed;
            top: 70px;
            right: 20px;
            width: 40px;
            height: 40px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 20px;
            cursor: pointer;
            pointer-events: auto;
            transition: all 0.3s;
        }
        
        .settings-button:hover {
            background: rgba(255, 69, 0, 0.3);
            border-color: #FF4500;
        }
        
        /* RESPONSIVE DESIGN */
        @media (max-width: 768px) {
            .stats-panel {
                display: none !important;
            }
            
            .game-title {
                font-size: 36px;
            }
            
            .karma-score {
                font-size: 28px;
            }
        }
        
        @media (min-width: 769px) {
            .game-controls {
                display: none;
            }
            
            .stats-panel {
                display: block !important;
            }
        }
        
        /* PARTICLE EFFECTS STYLE */
        .particle-container {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 50;
        }
    </style>
</head>
<body>
    <!-- LOADING SCREEN -->
    <div id="loadingScreen" class="loading-screen">
        <div class="loading-spinner"></div>
        <div class="loading-text">LOADING MULTIVERSE...</div>
    </div>
    
    <!-- START SCREEN -->
    <div id="startScreen" class="start-screen">
        <div class="game-logo-container">
            <div class="game-logo">🚀</div>
        </div>
        <h1 class="game-title">KARMA RUSH</h1>
        <p class="game-subtitle">REDDIT MULTIVERSE ADVENTURE</p>
        <div class="menu-buttons">
            <button class="menu-button" onclick="startGame()">PLAY NOW</button>
            <button class="menu-button secondary" onclick="showLeaderboard()">LEADERBOARD</button>
        </div>
    </div>
    
    <!-- GAME HUD -->
    <div class="game-hud">
        <div class="top-bar">
            <div class="dimension-indicator" onclick="switchDimension()">
                <div class="dimension-icon">🌍</div>
                <div class="dimension-name" id="dimensionName">r/all</div>
            </div>
            
            <div class="score-container">
                <div class="karma-score" id="karmaScore">0</div>
                <div class="karma-label">KARMA</div>
            </div>
            
            <div class="combo-container">
                <div class="combo-bar">
                    <div class="combo-fill" id="comboFill"></div>
                </div>
                <div class="combo-text" id="comboText">x1</div>
            </div>
        </div>
        
        <div class="achievement-popup" id="achievementPopup"></div>
        
        <div class="stats-panel show" id="statsPanel">
            <div class="stat-item">
                <span class="stat-label">Distance</span>
                <span class="stat-value" id="statDistance">0m</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Awards</span>
                <span class="stat-value" id="statAwards">0</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Best</span>
                <span class="stat-value" id="statBest">0</span>
            </div>
        </div>
        
        <div class="game-controls">
            <div class="control-button" ontouchstart="jump()" onclick="jump()">↑</div>
            <div class="control-button" ontouchstart="boost()" onclick="boost()">⚡</div>
        </div>
        
        <div class="settings-button" onclick="togglePause()">⚙️</div>
    </div>
    
    <!-- PAUSE MENU -->
    <div id="pauseMenu" class="pause-menu">
        <h2 class="pause-title">PAUSED</h2>
        <div class="menu-buttons">
            <button class="menu-button" onclick="resumeGame()">RESUME</button>
            <button class="menu-button secondary" onclick="restartGame()">RESTART</button>
            <button class="menu-button secondary" onclick="quitGame()">QUIT</button>
        </div>
    </div>
    
    <!-- 3D CANVAS -->
    <canvas id="gameCanvas"></canvas>
    
    <!-- PARTICLE CONTAINER -->
    <div class="particle-container" id="particleContainer"></div>
    
    <script>
        // ==========================================
        // PROFESSIONAL GAME ENGINE
        // Ultimate winning version with all features
        // ==========================================
        
        // Game state
        let scene, camera, renderer;
        let player, playerModel, playerVelocity = 0;
        let obstacles = [];
        let collectibles = [];
        let particles = [];
        let backgroundElements = [];
        
        // Game variables
        let karma = 0;
        let multiplier = 1;
        let combo = 0;
        let maxCombo = 0;
        let distance = 0;
        let awardsCollected = 0;
        let currentDimension = 'all';
        let gameRunning = false;
        let gamePaused = false;
        let clock = new THREE.Clock();
        let deltaTime = 0;
        let elapsedTime = 0;
        
        // Performance
        let frameCount = 0;
        let lastObstacleZ = -100;
        
        // Audio system
        let audioContext = null;
        let masterGain = null;
        let musicGain = null;
        let sfxGain = null;
        let musicNodes = {};
        let isMusicPlaying = true;
        
        // Achievements
        const achievements = {
            firstFlight: { name: "First Flight!", icon: "🎯", unlocked: false },
            karmaKing: { name: "Karma King!", icon: "👑", unlocked: false },
            comboMaster: { name: "Combo Master!", icon: "🔥", unlocked: false },
            collector: { name: "Award Collector!", icon: "🏆", unlocked: false },
            explorer: { name: "Dimension Explorer!", icon: "🌌", unlocked: false }
        };
        
        // High scores
        let highScore = localStorage.getItem('karmaRushHighScore') || 0;
        
        // Dimension configurations
        const dimensions = {
            'all': {
                name: 'r/all',
                icon: '🌍',
                skyColor: 0x1a1a2e,
                fogColor: 0x16213e,
                lightColor: 0xffffff,
                speed: 5,
                gravity: -30,
                particleColor: 0xFF4500,
                theme: {
                    primary: 0xFF4500,
                    secondary: 0xFFD700,
                    accent: 0x00D4FF
                }
            },
            'gaming': {
                name: 'r/gaming',
                icon: '🎮',
                skyColor: 0x2d0033,
                fogColor: 0x4a0055,
                lightColor: 0xff00ff,
                speed: 7,
                gravity: -28,
                particleColor: 0xFF00FF,
                theme: {
                    primary: 0xFF00FF,
                    secondary: 0x00FFFF,
                    accent: 0xFFFF00
                }
            },
            'memes': {
                name: 'r/memes',
                icon: '😂',
                skyColor: 0x003300,
                fogColor: 0x005500,
                lightColor: 0x00ff00,
                speed: 10,
                gravity: -35,
                particleColor: 0x00FF00,
                theme: {
                    primary: 0x00FF00,
                    secondary: 0xFFFF00,
                    accent: 0xFF00FF
                }
            },
            'science': {
                name: 'r/science',
                icon: '🔬',
                skyColor: 0x000033,
                fogColor: 0x000066,
                lightColor: 0x00ffff,
                speed: 4,
                gravity: -20,
                particleColor: 0x00FFFF,
                theme: {
                    primary: 0x00FFFF,
                    secondary: 0x0099FF,
                    accent: 0xFFFFFF
                }
            },
            'aww': {
                name: 'r/aww',
                icon: '🐾',
                skyColor: 0x330022,
                fogColor: 0x550033,
                lightColor: 0xffaaff,
                speed: 3,
                gravity: -15,
                particleColor: 0xFFAAFF,
                theme: {
                    primary: 0xFFAAFF,
                    secondary: 0xFFCCFF,
                    accent: 0xFF69B4
                }
            }
        };
        
        // Initialize the game
        window.addEventListener('DOMContentLoaded', () => {
            setTimeout(() => {
                document.getElementById('loadingScreen').classList.add('hidden');
                initAudio();
                updateHighScore();
            }, 1500);
        });
        
        // START GAME
        function startGame() {
            document.getElementById('startScreen').classList.add('hidden');
            
            initThreeJS();
            createWorld();
            createPlayer();
            createInitialObstacles();
            setupControls();
            startMusic();
            
            gameRunning = true;
            gamePaused = false;
            
            animate();
            
            // Start game loops
            setInterval(updateDistance, 100);
            setInterval(spawnCollectible, 3000);
            
            // Show first flight achievement
            setTimeout(() => {
                if (!achievements.firstFlight.unlocked) {
                    unlockAchievement('firstFlight');
                }
            }, 1000);
        }
        
        // INITIALIZE THREE.JS
        function initThreeJS() {
            const canvas = document.getElementById('gameCanvas');
            
            // Scene setup
            scene = new THREE.Scene();
            const dim = dimensions[currentDimension];
            scene.fog = new THREE.Fog(dim.fogColor, 30, 200);
            scene.background = new THREE.Color(dim.skyColor);
            
            // Camera setup - Professional FOV and position
            camera = new THREE.PerspectiveCamera(
                50,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.set(0, 8, 20);
            camera.lookAt(0, 5, 0);
            
            // Renderer setup - Optimized for quality and performance
            renderer = new THREE.WebGLRenderer({ 
                canvas: canvas,
                antialias: true,
                alpha: false,
                powerPreference: "high-performance",
                stencil: false,
                depth: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            
            // Handle resize
            window.addEventListener('resize', onWindowResize);
        }
        
        // CREATE WORLD
        function createWorld() {
            const dim = dimensions[currentDimension];
            
            // Professional lighting setup
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(dim.lightColor, 0.8);
            directionalLight.position.set(10, 20, 10);
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.left = -30;
            directionalLight.shadow.camera.right = 30;
            directionalLight.shadow.camera.top = 30;
            directionalLight.shadow.camera.bottom = -30;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);
            
            // Add rim light for professional look
            const rimLight = new THREE.DirectionalLight(0xffffff, 0.3);
            rimLight.position.set(-10, 10, -10);
            scene.add(rimLight);
            
            // Create stylized ground
            const groundGeometry = new THREE.PlaneGeometry(100, 500);
            const groundMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x1a1a2e,
                shininess: 20,
                specular: 0x222244
            });
            
            for(let i = 0; i < 3; i++) {
                const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.rotation.x = -Math.PI / 2;
                ground.position.y = -3;
                ground.position.z = -i * 500;
                ground.receiveShadow = true;
                ground.name = 'ground';
                scene.add(ground);
                
                // Add grid overlay for style
                const gridHelper = new THREE.GridHelper(100, 20, dim.theme.accent, 0x222244);
                gridHelper.position.y = -2.9;
                gridHelper.position.z = -i * 500;
                gridHelper.name = 'grid';
                scene.add(gridHelper);
            }
            
            // Create animated background elements
            createBackgroundElements();
            
            // Create particle field
            createParticleField();
        }
        
        // CREATE BACKGROUND ELEMENTS
        function createBackgroundElements() {
            const dim = dimensions[currentDimension];
            
            // Floating geometric shapes
            for(let i = 0; i < 30; i++) {
                const geometries = [
                    new THREE.TetrahedronGeometry(1),
                    new THREE.OctahedronGeometry(1),
                    new THREE.IcosahedronGeometry(1)
                ];
                
                const geometry = geometries[Math.floor(Math.random() * geometries.length)];
                const material = new THREE.MeshPhongMaterial({
                    color: dim.theme.accent,
                    emissive: dim.theme.accent,
                    emissiveIntensity: 0.2,
                    transparent: true,
                    opacity: 0.3
                });
                
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(
                    (Math.random() - 0.5) * 100,
                    Math.random() * 30 + 10,
                    (Math.random() - 0.5) * 200
                );
                mesh.rotation.set(
                    Math.random() * Math.PI,
                    Math.random() * Math.PI,
                    Math.random() * Math.PI
                );
                mesh.scale.setScalar(Math.random() * 2 + 0.5);
                mesh.name = 'backgroundElement';
                
                backgroundElements.push({
                    mesh: mesh,
                    rotationSpeed: {
                        x: (Math.random() - 0.5) * 0.02,
                        y: (Math.random() - 0.5) * 0.02,
                        z: (Math.random() - 0.5) * 0.02
                    },
                    floatSpeed: Math.random() * 0.003 + 0.001,
                    floatOffset: Math.random() * Math.PI * 2
                });
                
                scene.add(mesh);
            }
        }
        
        // CREATE PARTICLE FIELD
        function createParticleField() {
            const particleCount = 2000;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            const sizes = new Float32Array(particleCount);
            
            const dim = dimensions[currentDimension];
            const color = new THREE.Color(dim.particleColor);
            
            for(let i = 0; i < particleCount; i++) {
                positions[i * 3] = (Math.random() - 0.5) * 200;
                positions[i * 3 + 1] = Math.random() * 100;
                positions[i * 3 + 2] = (Math.random() - 0.5) * 200;
                
                colors[i * 3] = color.r;
                colors[i * 3 + 1] = color.g;
                colors[i * 3 + 2] = color.b;
                
                sizes[i] = Math.random() * 0.5 + 0.1;
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            
            const material = new THREE.PointsMaterial({
                size: 0.5,
                vertexColors: true,
                transparent: true,
                opacity: 0.6,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            
            const particleSystem = new THREE.Points(geometry, material);
            particleSystem.name = 'particleField';
            scene.add(particleSystem);
        }
        
        // CREATE PLAYER - Professional Snoo Model
        function createPlayer() {
            const playerGroup = new THREE.Group();
            const dim = dimensions[currentDimension];
            
            // Body
            const bodyGeometry = new THREE.SphereGeometry(1, 32, 32);
            const bodyMaterial = new THREE.MeshPhongMaterial({
                color: 0xFF4500,
                emissive: 0xFF4500,
                emissiveIntensity: 0.1,
                shininess: 100,
                specular: 0xFFFFFF
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.castShadow = true;
            body.receiveShadow = true;
            playerGroup.add(body);
            
            // Head
            const headGeometry = new THREE.SphereGeometry(0.8, 32, 32);
            const head = new THREE.Mesh(headGeometry, bodyMaterial);
            head.position.y = 1.3;
            head.castShadow = true;
            playerGroup.add(head);
            
            // Eyes with glow
            const eyeGeometry = new THREE.SphereGeometry(0.25, 16, 16);
            const eyeMaterial = new THREE.MeshPhongMaterial({
                color: 0xFFFFFF,
                emissive: 0xFFFFFF,
                emissiveIntensity: 0.5
            });
            
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(-0.3, 1.3, 0.6);
            playerGroup.add(leftEye);
            
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.3, 1.3, 0.6);
            playerGroup.add(rightEye);
            
            // Pupils that follow movement
            const pupilGeometry = new THREE.SphereGeometry(0.12, 8, 8);
            const pupilMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
            
            const leftPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
            leftPupil.position.set(-0.3, 1.3, 0.75);
            leftPupil.name = 'leftPupil';
            playerGroup.add(leftPupil);
            
            const rightPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
            rightPupil.position.set(0.3, 1.3, 0.75);
            rightPupil.name = 'rightPupil';
            playerGroup.add(rightPupil);
            
            // Antenna
            const antennaGeometry = new THREE.CylinderGeometry(0.05, 0.05, 1);
            const antenna = new THREE.Mesh(antennaGeometry, bodyMaterial);
            antenna.position.y = 2;
            antenna.name = 'antenna';
            playerGroup.add(antenna);
            
            const antennaBallGeometry = new THREE.SphereGeometry(0.2);
            const antennaBall = new THREE.Mesh(antennaBallGeometry, bodyMaterial);
            antennaBall.position.y = 2.5;
            playerGroup.add(antennaBall);
            
            // Ears
            const earGeometry = new THREE.SphereGeometry(0.3, 16, 16);
            
            const leftEar = new THREE.Mesh(earGeometry, bodyMaterial);
            leftEar.position.set(-0.7, 1.5, 0);
            leftEar.scale.set(1, 1.5, 0.5);
            playerGroup.add(leftEar);
            
            const rightEar = new THREE.Mesh(earGeometry, bodyMaterial);
            rightEar.position.set(0.7, 1.5, 0);
            rightEar.scale.set(1, 1.5, 0.5);
            playerGroup.add(rightEar);
            
            // Add glow effect
            const glowGeometry = new THREE.SphereGeometry(1.8, 32, 32);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: dim.theme.primary,
                transparent: true,
                opacity: 0.15,
                side: THREE.BackSide
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            glow.name = 'playerGlow';
            playerGroup.add(glow);
            
            // Position player
            playerGroup.position.set(0, 5, 0);
            
            player = playerGroup;
            playerModel = playerGroup;
            scene.add(player);
            
            // Create player trail
            createPlayerTrail();
        }
        
        // CREATE PLAYER TRAIL
        function createPlayerTrail() {
            const trailGeometry = new THREE.BufferGeometry();
            const trailPositions = new Float32Array(150);
            const trailColors = new Float32Array(150);
            
            for(let i = 0; i < 50; i++) {
                trailPositions[i * 3] = 0;
                trailPositions[i * 3 + 1] = 0;
                trailPositions[i * 3 + 2] = 0;
                
                const intensity = 1 - (i / 50);
                trailColors[i * 3] = 1 * intensity;
                trailColors[i * 3 + 1] = 0.5 * intensity;
                trailColors[i * 3 + 2] = 0;
            }
            
            trailGeometry.setAttribute('position', new THREE.BufferAttribute(trailPositions, 3));
            trailGeometry.setAttribute('color', new THREE.BufferAttribute(trailColors, 3));
            
            const trailMaterial = new THREE.PointsMaterial({
                size: 0.5,
                vertexColors: true,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            
            const trail = new THREE.Points(trailGeometry, trailMaterial);
            trail.name = 'playerTrail';
            scene.add(trail);
        }
        
        // CREATE OBSTACLES
        function createObstacle(zPosition) {
            const dim = dimensions[currentDimension];
            const gap = 9;
            const gapY = Math.random() * 6 - 3;
            
            // Create stylized obstacles
            const obstacleGroup = new THREE.Group();
            
            // Top obstacle
            const topGeometry = new THREE.BoxGeometry(4, 25, 4);
            const topMaterial = new THREE.MeshPhongMaterial({
                color: 0x5865F2,
                emissive: 0x5865F2,
                emissiveIntensity: 0.05,
                shininess: 100
            });
            const topObstacle = new THREE.Mesh(topGeometry, topMaterial);
            topObstacle.position.set(0, 18 + gapY + gap/2, zPosition);
            topObstacle.castShadow = true;
            topObstacle.receiveShadow = true;
            scene.add(topObstacle);
            
            // Bottom obstacle
            const bottomObstacle = new THREE.Mesh(topGeometry, topMaterial);
            bottomObstacle.position.set(0, -7 + gapY - gap/2, zPosition);
            bottomObstacle.castShadow = true;
            bottomObstacle.receiveShadow = true;
            scene.add(bottomObstacle);
            
            // Add downvote arrows on obstacles
            const arrowGeometry = new THREE.ConeGeometry(0.5, 1, 4);
            const arrowMaterial = new THREE.MeshPhongMaterial({
                color: 0xFFFFFF,
                emissive: 0xFFFFFF,
                emissiveIntensity: 0.3
            });
            
            const topArrow = new THREE.Mesh(arrowGeometry, arrowMaterial);
            topArrow.position.set(0, 8 + gapY + gap/2, zPosition + 1.5);
            scene.add(topArrow);
            
            const bottomArrow = new THREE.Mesh(arrowGeometry, arrowMaterial);
            bottomArrow.position.set(0, 3 + gapY - gap/2, zPosition + 1.5);
            bottomArrow.rotation.z = Math.PI;
            scene.add(bottomArrow);
            
            // Upvote collectible in gap
            const upvoteGeometry = new THREE.ConeGeometry(0.6, 1.2, 4);
            const upvoteMaterial = new THREE.MeshPhongMaterial({
                color: 0xFF8C00,
                emissive: 0xFF8C00,
                emissiveIntensity: 0.5,
                shininess: 200
            });
            const upvote = new THREE.Mesh(upvoteGeometry, upvoteMaterial);
            upvote.position.set(0, gapY + gap/2, zPosition);
            upvote.rotation.z = Math.PI;
            upvote.castShadow = true;
            upvote.name = 'upvote';
            scene.add(upvote);
            
            // Add glow to upvote
            const upvoteGlow = new THREE.PointLight(0xFF8C00, 0.5, 10);
            upvoteGlow.position.copy(upvote.position);
            scene.add(upvoteGlow);
            
            obstacles.push({
                top: topObstacle,
                bottom: bottomObstacle,
                topArrow: topArrow,
                bottomArrow: bottomArrow,
                upvote: upvote,
                upvoteGlow: upvoteGlow,
                passed: false,
                gapY: gapY
            });
            
            lastObstacleZ = zPosition;
        }
        
        // CREATE INITIAL OBSTACLES
        function createInitialObstacles() {
            for(let i = 0; i < 5; i++) {
                createObstacle(-100 - i * 35);
            }
        }
        
        // SPAWN COLLECTIBLE
        function spawnCollectible() {
            if(!gameRunning || gamePaused) return;
            
            const dim = dimensions[currentDimension];
            
            // Random chance for special collectibles
            const rand = Math.random();
            let collectibleType, geometry, material, value, name;
            
            if(rand < 0.05) {
                // Platinum award (super rare)
                collectibleType = 'platinum';
                geometry = new THREE.IcosahedronGeometry(0.8);
                material = new THREE.MeshPhongMaterial({
                    color: 0xE5E4E2,
                    emissive: 0x00FFFF,
                    emissiveIntensity: 0.8,
                    shininess: 500
                });
                value = 2000;
                name = 'PLATINUM';
            } else if(rand < 0.2) {
                // Gold award
                collectibleType = 'gold';
                geometry = new THREE.OctahedronGeometry(0.6);
                material = new THREE.MeshPhongMaterial({
                    color: 0xFFD700,
                    emissive: 0xFFD700,
                    emissiveIntensity: 0.6,
                    shininess: 300
                });
                value = 500;
                name = 'GOLD';
            } else {
                // Silver award
                collectibleType = 'silver';
                geometry = new THREE.TetrahedronGeometry(0.5);
                material = new THREE.MeshPhongMaterial({
                    color: 0xC0C0C0,
                    emissive: 0xC0C0C0,
                    emissiveIntensity: 0.4,
                    shininess: 200
                });
                value = 100;
                name = 'SILVER';
            }
            
            const collectible = new THREE.Mesh(geometry, material);
            collectible.position.set(
                (Math.random() - 0.5) * 6,
                Math.random() * 10,
                -100
            );
            collectible.castShadow = true;
            collectible.userData = {
                type: collectibleType,
                value: value,
                name: name
            };
            
            // Add glow
            const glowLight = new THREE.PointLight(material.emissive, 1, 15);
            glowLight.position.copy(collectible.position);
            scene.add(glowLight);
            
            collectible.userData.glow = glowLight;
            collectibles.push(collectible);
            scene.add(collectible);
        }
        
        // SETUP CONTROLS
        function setupControls() {
            // Keyboard
            document.addEventListener('keydown', (e) => {
                if(e.code === 'Space') {
                    e.preventDefault();
                    jump();
                }
                if(e.code === 'KeyX') {
                    boost();
                }
                if(e.code === 'Escape') {
                    togglePause();
                }
            });
            
            // Mouse
            document.addEventListener('click', (e) => {
                if(e.target.id === 'gameCanvas' && gameRunning && !gamePaused) {
                    jump();
                }
            });
            
            // Touch
            document.addEventListener('touchstart', (e) => {
                if(e.target.id === 'gameCanvas' && gameRunning && !gamePaused) {
                    e.preventDefault();
                    jump();
                }
            }, { passive: false });
        }
        
        // JUMP
        function jump() {
            if(!gameRunning || gamePaused) return;
            
            playerVelocity = 15;
            
            // Effects
            playSound('jump');
            createJumpParticles();
            
            // Update combo
            combo++;
            if(combo > maxCombo) maxCombo = combo;
            updateCombo();
            
            // Check achievements
            if(combo >= 10 && !achievements.comboMaster.unlocked) {
                unlockAchievement('comboMaster');
            }
        }
        
        // BOOST
        function boost() {
            if(!gameRunning || gamePaused || multiplier > 1) return;
            
            multiplier = 3;
            playSound('powerup');
            showNotification('3X BOOST!');
            
            // Visual effect
            const boostDuration = 3000;
            player.getObjectByName('playerGlow').material.opacity = 0.3;
            player.getObjectByName('playerGlow').material.color = new THREE.Color(0xFFD700);
            
            setTimeout(() => {
                multiplier = 1;
                player.getObjectByName('playerGlow').material.opacity = 0.15;
                player.getObjectByName('playerGlow').material.color = new THREE.Color(0xFF4500);
            }, boostDuration);
        }
        
        // SWITCH DIMENSION
        function switchDimension() {
            if(!gameRunning) return;
            
            const dims = Object.keys(dimensions);
            let index = dims.indexOf(currentDimension);
            index = (index + 1) % dims.length;
            currentDimension = dims[index];
            
            const dim = dimensions[currentDimension];
            
            // Update scene
            scene.fog.color = new THREE.Color(dim.fogColor);
            scene.background = new THREE.Color(dim.skyColor);
            
            // Update UI
            document.getElementById('dimensionName').textContent = dim.name;
            document.querySelector('.dimension-icon').textContent = dim.icon;
            
            // Update lights
            scene.traverse((child) => {
                if(child.type === 'DirectionalLight') {
                    child.color = new THREE.Color(dim.lightColor);
                }
            });
            
            // Effects
            playSound('dimension');
            showNotification(`DIMENSION: ${dim.name}`);
            
            // Check achievement
            const visitedDimensions = new Set();
            visitedDimensions.add(currentDimension);
            if(visitedDimensions.size >= 5 && !achievements.explorer.unlocked) {
                unlockAchievement('explorer');
            }
        }
        
        // CREATE JUMP PARTICLES
        function createJumpParticles() {
            const particleCount = 30;
            const dim = dimensions[currentDimension];
            
            for(let i = 0; i < particleCount; i++) {
                const particle = document.createElement('div');
                particle.style.position = 'fixed';
                particle.style.width = '4px';
                particle.style.height = '4px';
                particle.style.background = `linear-gradient(135deg, #FF4500, #FFD700)`;
                particle.style.borderRadius = '50%';
                particle.style.pointerEvents = 'none';
                particle.style.zIndex = '60';
                
                const startX = window.innerWidth / 2;
                const startY = window.innerHeight / 2;
                
                particle.style.left = startX + 'px';
                particle.style.top = startY + 'px';
                
                document.getElementById('particleContainer').appendChild(particle);
                
                const angle = (Math.PI * 2 * i) / particleCount;
                const velocity = Math.random() * 5 + 2;
                const vx = Math.cos(angle) * velocity;
                const vy = Math.sin(angle) * velocity;
                
                let opacity = 1;
                let scale = 1;
                
                const animateParticle = () => {
                    const currentX = parseFloat(particle.style.left);
                    const currentY = parseFloat(particle.style.top);
                    
                    particle.style.left = (currentX + vx) + 'px';
                    particle.style.top = (currentY + vy + 0.5) + 'px';
                    
                    opacity -= 0.02;
                    scale -= 0.01;
                    
                    particle.style.opacity = opacity;
                    particle.style.transform = `scale(${scale})`;
                    
                    if(opacity > 0) {
                        requestAnimationFrame(animateParticle);
                    } else {
                        particle.remove();
                    }
                };
                
                requestAnimationFrame(animateParticle);
            }
        }
        
        // AUDIO SYSTEM
        function initAudio() {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            
            masterGain = audioContext.createGain();
            masterGain.gain.value = 0.3;
            masterGain.connect(audioContext.destination);
            
            musicGain = audioContext.createGain();
            musicGain.gain.value = 0.5;
            musicGain.connect(masterGain);
            
            sfxGain = audioContext.createGain();
            sfxGain.gain.value = 0.7;
            sfxGain.connect(masterGain);
        }
        
        // START MUSIC
        function startMusic() {
            if(!audioContext) return;
            
            // Create oscillators for background music
            const bassOsc = audioContext.createOscillator();
            const bassGain = audioContext.createGain();
            bassOsc.type = 'sawtooth';
            bassOsc.frequency.value = 55;
            bassGain.gain.value = 0.3;
            bassOsc.connect(bassGain);
            bassGain.connect(musicGain);
            bassOsc.start();
            
            const melodyOsc = audioContext.createOscillator();
            const melodyGain = audioContext.createGain();
            melodyOsc.type = 'square';
            melodyGain.gain.value = 0.1;
            melodyOsc.connect(melodyGain);
            melodyGain.connect(musicGain);
            melodyOsc.start();
            
            // Create melody pattern
            const notes = [440, 494, 523, 587, 659, 587, 523, 494];
            let noteIndex = 0;
            
            setInterval(() => {
                if(isMusicPlaying && !gamePaused) {
                    melodyOsc.frequency.setValueAtTime(
                        notes[noteIndex % notes.length],
                        audioContext.currentTime
                    );
                    noteIndex++;
                    
                    // Add rhythm
                    melodyGain.gain.setValueAtTime(0.1, audioContext.currentTime);
                    melodyGain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                    melodyGain.gain.setValueAtTime(0.1, audioContext.currentTime + 0.15);
                }
            }, 200);
            
            musicNodes = { bassOsc, melodyOsc };
        }
        
        // PLAY SOUND
        function playSound(type) {
            if(!audioContext) return;
            
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            osc.connect(gain);
            gain.connect(sfxGain);
            
            const now = audioContext.currentTime;
            
            switch(type) {
                case 'jump':
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(400, now);
                    osc.frequency.exponentialRampToValueAtTime(800, now + 0.1);
                    gain.gain.setValueAtTime(0.3, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
                    osc.start(now);
                    osc.stop(now + 0.2);
                    break;
                    
                case 'collect':
                    osc.type = 'sine';
                    // Arpeggio
                    [523, 659, 784, 1047].forEach((freq, i) => {
                        const o = audioContext.createOscillator();
                        const g = audioContext.createGain();
                        o.frequency.value = freq;
                        o.type = 'sine';
                        g.gain.setValueAtTime(0.2, now + i * 0.05);
                        g.gain.exponentialRampToValueAtTime(0.01, now + i * 0.05 + 0.2);
                        o.connect(g);
                        g.connect(sfxGain);
                        o.start(now + i * 0.05);
                        o.stop(now + i * 0.05 + 0.2);
                    });
                    break;
                    
                case 'powerup':
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(200, now);
                    osc.frequency.exponentialRampToValueAtTime(800, now + 0.3);
                    gain.gain.setValueAtTime(0.3, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.4);
                    osc.start(now);
                    osc.stop(now + 0.4);
                    break;
                    
                case 'dimension':
                    // Swoosh sound
                    const noise = audioContext.createOscillator();
                    const noiseGain = audioContext.createGain();
                    noise.type = 'sawtooth';
                    noise.frequency.setValueAtTime(1000, now);
                    noise.frequency.exponentialRampToValueAtTime(100, now + 0.5);
                    noiseGain.gain.setValueAtTime(0.1, now);
                    noiseGain.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
                    noise.connect(noiseGain);
                    noiseGain.connect(sfxGain);
                    noise.start(now);
                    noise.stop(now + 0.5);
                    break;
                    
                case 'crash':
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(400, now);
                    osc.frequency.exponentialRampToValueAtTime(50, now + 0.5);
                    gain.gain.setValueAtTime(0.5, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
                    osc.start(now);
                    osc.stop(now + 0.5);
                    break;
            }
        }
        
        // ANIMATION LOOP
        function animate() {
            if(!gameRunning) return;
            
            requestAnimationFrame(animate);
            
            if(gamePaused) return;
            
            deltaTime = clock.getDelta();
            elapsedTime = clock.getElapsedTime();
            frameCount++;
            
            const dim = dimensions[currentDimension];
            
            // Update player physics
            playerVelocity += dim.gravity * deltaTime;
            player.position.y += playerVelocity * deltaTime;
            
            // Rotate player
            player.rotation.z = playerVelocity * 0.02;
            player.rotation.y += 0.01;
            
            // Animate player parts
            const antenna = player.getObjectByName('antenna');
            if(antenna) {
                antenna.rotation.z = Math.sin(elapsedTime * 3) * 0.3;
            }
            
            // Animate pupils to look forward
            const leftPupil = player.getObjectByName('leftPupil');
            const rightPupil = player.getObjectByName('rightPupil');
            if(leftPupil && rightPupil) {
                const lookOffset = playerVelocity * 0.002;
                leftPupil.position.y = 1.3 + lookOffset;
                rightPupil.position.y = 1.3 + lookOffset;
            }
            
            // Update camera
            camera.position.y += (player.position.y + 3 - camera.position.y) * 0.1;
            
            // Camera shake on boost
            if(multiplier > 1) {
                camera.position.x = Math.sin(elapsedTime * 10) * 0.1;
            } else {
                camera.position.x += (0 - camera.position.x) * 0.1;
            }
            
            // Update obstacles
            updateObstacles();
            
            // Update collectibles
            updateCollectibles();
            
            // Update background elements
            updateBackgroundElements();
            
            // Update particle field
            updateParticleField();
            
            // Update trail
            updatePlayerTrail();
            
            // Update environment
            updateEnvironment();
            
            // Check boundaries
            if(player.position.y < -2) {
                gameOver();
            }
            if(player.position.y > 25) {
                player.position.y = 25;
                playerVelocity = -2;
            }
            
            // Update combo decay
            if(combo > 0 && frameCount % 120 === 0) {
                combo = Math.max(0, combo - 1);
                updateCombo();
            }
            
            // Render
            renderer.render(scene, camera);
        }
        
        // UPDATE OBSTACLES
        function updateObstacles() {
            const dim = dimensions[currentDimension];
            
            for(let i = obstacles.length - 1; i >= 0; i--) {
                const obstacle = obstacles[i];
                
                // Move obstacles
                obstacle.top.position.z += dim.speed * deltaTime * multiplier;
                obstacle.bottom.position.z += dim.speed * deltaTime * multiplier;
                obstacle.topArrow.position.z += dim.speed * deltaTime * multiplier;
                obstacle.bottomArrow.position.z += dim.speed * deltaTime * multiplier;
                
                if(obstacle.upvote) {
                    obstacle.upvote.position.z += dim.speed * deltaTime * multiplier;
                    obstacle.upvote.rotation.y += 0.03;
                    obstacle.upvote.position.y = obstacle.gapY + Math.sin(elapsedTime * 2) * 0.2;
                    obstacle.upvoteGlow.position.copy(obstacle.upvote.position);
                }
                
                // Animate arrows
                obstacle.topArrow.position.y = 8 + obstacle.gapY + 9/2 + Math.sin(elapsedTime * 3) * 0.3;
                obstacle.bottomArrow.position.y = 3 + obstacle.gapY - 9/2 + Math.sin(elapsedTime * 3 + Math.PI) * 0.3;
                
                // Check if passed
                if(!obstacle.passed && obstacle.top.position.z > player.position.z) {
                    obstacle.passed = true;
                    karma += Math.floor(10 * multiplier);
                    updateScore();
                }
                
                // Check upvote collection
                if(obstacle.upvote) {
                    const dist = player.position.distanceTo(obstacle.upvote.position);
                    if(dist < 2) {
                        scene.remove(obstacle.upvote);
                        scene.remove(obstacle.upvoteGlow);
                        obstacle.upvote = null;
                        karma += Math.floor(50 * multiplier);
                        updateScore();
                        playSound('collect');
                        showNotification('+50');
                    }
                }
                
                // Check collision
                if(Math.abs(player.position.z - obstacle.top.position.z) < 2) {
                    if(player.position.y > obstacle.top.position.y - 12.5 ||
                       player.position.y < obstacle.bottom.position.y + 12.5) {
                        gameOver();
                    }
                }
                
                // Remove old obstacles
                if(obstacle.top.position.z > 25) {
                    scene.remove(obstacle.top);
                    scene.remove(obstacle.bottom);
                    scene.remove(obstacle.topArrow);
                    scene.remove(obstacle.bottomArrow);
                    if(obstacle.upvote) {
                        scene.remove(obstacle.upvote);
                        scene.remove(obstacle.upvoteGlow);
                    }
                    obstacles.splice(i, 1);
                    
                    // Create new obstacle
                    createObstacle(lastObstacleZ - 35);
                }
            }
        }
        
        // UPDATE COLLECTIBLES
        function updateCollectibles() {
            const dim = dimensions[currentDimension];
            
            for(let i = collectibles.length - 1; i >= 0; i--) {
                const collectible = collectibles[i];
                
                // Move and rotate
                collectible.position.z += dim.speed * deltaTime * multiplier;
                collectible.rotation.x += 0.02;
                collectible.rotation.y += 0.03;
                collectible.position.y += Math.sin(elapsedTime * 3 + i) * 0.01;
                
                if(collectible.userData.glow) {
                    collectible.userData.glow.position.copy(collectible.position);
                }
                
                // Check collection
                const dist = player.position.distanceTo(collectible.position);
                if(dist < 2.5) {
                    karma += collectible.userData.value * multiplier;
                    awardsCollected++;
                    updateScore();
                    updateStats();
                    playSound('powerup');
                    showNotification(`${collectible.userData.name} +${collectible.userData.value}`);
                    
                    scene.remove(collectible);
                    if(collectible.userData.glow) {
                        scene.remove(collectible.userData.glow);
                    }
                    collectibles.splice(i, 1);
                    
                    // Check achievement
                    if(awardsCollected >= 10 && !achievements.collector.unlocked) {
                        unlockAchievement('collector');
                    }
                }
                
                // Remove if too far
                if(collectible.position.z > 30) {
                    scene.remove(collectible);
                    if(collectible.userData.glow) {
                        scene.remove(collectible.userData.glow);
                    }
                    collectibles.splice(i, 1);
                }
            }
        }
        
        // UPDATE BACKGROUND ELEMENTS
        function updateBackgroundElements() {
            backgroundElements.forEach(element => {
                // Rotate
                element.mesh.rotation.x += element.rotationSpeed.x;
                element.mesh.rotation.y += element.rotationSpeed.y;
                element.mesh.rotation.z += element.rotationSpeed.z;
                
                // Float
                element.mesh.position.y += Math.sin(elapsedTime * element.floatSpeed + element.floatOffset) * 0.05;
                
                // Move with world
                element.mesh.position.z += dimensions[currentDimension].speed * deltaTime * 0.3;
                
                // Reset position
                if(element.mesh.position.z > 50) {
                    element.mesh.position.z = -100;
                    element.mesh.position.x = (Math.random() - 0.5) * 100;
                }
            });
        }
        
        // UPDATE PARTICLE FIELD
        function updateParticleField() {
            const particleField = scene.getObjectByName('particleField');
            if(particleField) {
                particleField.rotation.y += 0.0001;
                
                const positions = particleField.geometry.attributes.position.array;
                for(let i = 0; i < positions.length; i += 3) {
                    positions[i + 2] += dimensions[currentDimension].speed * deltaTime * 0.5;
                    if(positions[i + 2] > 100) {
                        positions[i + 2] = -100;
                    }
                }
                particleField.geometry.attributes.position.needsUpdate = true;
            }
        }
        
        // UPDATE PLAYER TRAIL
        function updatePlayerTrail() {
            const trail = scene.getObjectByName('playerTrail');
            if(trail) {
                const positions = trail.geometry.attributes.position.array;
                
                // Shift positions
                for(let i = positions.length - 3; i >= 3; i -= 3) {
                    positions[i] = positions[i - 3];
                    positions[i + 1] = positions[i - 2];
                    positions[i + 2] = positions[i - 1];
                }
                
                // Add new position
                positions[0] = player.position.x + (Math.random() - 0.5) * 0.2;
                positions[1] = player.position.y + (Math.random() - 0.5) * 0.2;
                positions[2] = player.position.z;
                
                trail.geometry.attributes.position.needsUpdate = true;
            }
        }
        
        // UPDATE ENVIRONMENT
        function updateEnvironment() {
            const dim = dimensions[currentDimension];
            
            scene.traverse((child) => {
                if(child.name === 'ground' || child.name === 'grid') {
                    child.position.z += dim.speed * deltaTime * multiplier;
                    if(child.position.z > 250) {
                        child.position.z -= 1500;
                    }
                }
            });
        }
        
        // UPDATE SCORE
        function updateScore() {
            document.getElementById('karmaScore').textContent = Math.floor(karma);
            
            // Check high score
            if(karma > highScore) {
                highScore = karma;
                updateHighScore();
            }
            
            // Check achievement
            if(karma >= 1000 && !achievements.karmaKing.unlocked) {
                unlockAchievement('karmaKing');
            }
        }
        
        // UPDATE COMBO
        function updateCombo() {
            const comboBar = document.getElementById('comboFill');
            const comboText = document.getElementById('comboText');
            
            const comboPercent = Math.min((combo / 20) * 100, 100);
            comboBar.style.width = comboPercent + '%';
            
            if(combo > 10) {
                comboText.textContent = `x${combo}`;
                comboText.style.color = '#FFD700';
                comboBar.style.background = 'linear-gradient(90deg, #FFD700, #FFA500)';
            } else if(combo > 5) {
                comboText.textContent = `x${combo}`;
                comboText.style.color = '#FFA500';
                comboBar.style.background = 'linear-gradient(90deg, #FF4500, #FFD700)';
            } else {
                comboText.textContent = `x${combo}`;
                comboText.style.color = '#FF4500';
                comboBar.style.background = 'linear-gradient(90deg, #FF4500, #FF6B35)';
            }
        }
        
        // UPDATE STATS
        function updateStats() {
            document.getElementById('statAwards').textContent = awardsCollected;
        }
        
        // UPDATE DISTANCE
        function updateDistance() {
            if(gameRunning && !gamePaused) {
                distance += 1;
                document.getElementById('statDistance').textContent = Math.floor(distance) + 'm';
            }
        }
        
        // UPDATE HIGH SCORE
        function updateHighScore() {
            localStorage.setItem('karmaRushHighScore', highScore);
            document.getElementById('statBest').textContent = Math.floor(highScore);
        }
        
        // SHOW NOTIFICATION
        function showNotification(text) {
            const notif = document.createElement('div');
            notif.className = 'game-notification';
            notif.textContent = text;
            document.body.appendChild(notif);
            
            setTimeout(() => {
                notif.remove();
            }, 1000);
        }
        
        // UNLOCK ACHIEVEMENT
        function unlockAchievement(key) {
            const achievement = achievements[key];
            if(!achievement.unlocked) {
                achievement.unlocked = true;
                
                const popup = document.getElementById('achievementPopup');
                popup.textContent = `${achievement.icon} ${achievement.name}`;
                popup.classList.add('show');
                
                playSound('powerup');
                
                setTimeout(() => {
                    popup.classList.remove('show');
                }, 3000);
            }
        }
        
        // PAUSE FUNCTIONS
        function togglePause() {
            if(!gameRunning) return;
            
            gamePaused = !gamePaused;
            
            if(gamePaused) {
                document.getElementById('pauseMenu').classList.add('show');
                clock.stop();
            } else {
                document.getElementById('pauseMenu').classList.remove('show');
                clock.start();
            }
        }
        
        function resumeGame() {
            gamePaused = false;
            document.getElementById('pauseMenu').classList.remove('show');
            clock.start();
        }
        
        function restartGame() {
            location.reload();
        }
        
        function quitGame() {
            gameRunning = false;
            location.reload();
        }
        
        // SHOW LEADERBOARD
        function showLeaderboard() {
            alert('LEADERBOARD\n\n1. RedditKing - 50000\n2. KarmaMaster - 45000\n3. ProGamer - 40000\n4. You - ' + highScore);
        }
        
        // GAME OVER
        function gameOver() {
            gameRunning = false;
            playSound('crash');
            
            const finalStats = `
🎮 GAME OVER 🎮

Karma: ${Math.floor(karma)}
Distance: ${Math.floor(distance)}m
Awards: ${awardsCollected}
Max Combo: ${maxCombo}x
Best Score: ${Math.floor(highScore)}

${karma > highScore * 0.9 ? '🏆 AMAZING RUN!' : karma > highScore * 0.5 ? '⭐ GREAT JOB!' : '💪 KEEP TRYING!'}
            `;
            
            setTimeout(() => {
                if(confirm(finalStats + '\n\nPlay Again?')) {
                    location.reload();
                }
            }, 500);
        }
        
        // WINDOW RESIZE
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>
</html>